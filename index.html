<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Castle Courtyard Battle - Tactical Combat</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Philosopher:wght@400;700&display=swap');

    :root {
      --grid-size: 45px;
      --color-bg: #2b1810;
      --color-stone: #8b7d6b;
      --color-stone-dark: #5c5346;
      --color-grass: #4a6741;
      --color-grass-light: #5d7f54;
      --color-archer: #3498db;
      --color-knight: #c0392b;
      --color-movement: rgba(52, 152, 219, 0.25);
      --color-attack: rgba(231, 76, 60, 0.3);
      --color-los: rgba(241, 196, 15, 0.2);
      --color-path: rgba(155, 89, 182, 0.35);
      --color-wall: #6b5d52;
      --color-text: #f4e9d8;
      --color-accent: #d4af37;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Philosopher', sans-serif;
      background: linear-gradient(135deg, #2b1810 0%, #3d2817 50%, #2b1810 100%);
      color: var(--color-text);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      overflow-x: auto;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" /></filter><rect width="100" height="100" filter="url(%23noise)" opacity="0.05"/></svg>');
      pointer-events: none;
      opacity: 0.3;
    }

    .container {
      display: flex;
      gap: 30px;
      align-items: flex-start;
      position: relative;
      animation: fadeIn 0.8s ease;
      max-width: 100%;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .game-board {
      background: linear-gradient(135deg, #4a3f35 0%, #6b5d52 50%, #4a3f35 100%);
      padding: 25px;
      border-radius: 12px;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      border: 3px solid #8b7355;
      position: relative;
    }

    .game-board::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, #d4af37 0%, #f4e4c1 50%, #d4af37 100%);
      border-radius: 12px;
      z-index: -1;
      opacity: 0.3;
    }

    .board-title {
      font-family: 'Cinzel', serif;
      font-size: 1.4rem;
      text-align: center;
      margin-bottom: 15px;
      color: var(--color-accent);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      letter-spacing: 2px;
      font-weight: 700;
    }

    canvas {
      display: block;
      border: 2px solid #5c4a3a;
      box-shadow: 
        inset 0 0 20px rgba(0, 0, 0, 0.5),
        0 4px 15px rgba(0, 0, 0, 0.3);
      cursor: crosshair;
      background: #3d5a3d;
    }

    .info-panel {
      background: linear-gradient(135deg, #3d2817 0%, #4a3420 100%);
      padding: 25px;
      border-radius: 12px;
      min-width: 340px;
      border: 3px solid #6b5d52;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    .info-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--color-accent), transparent);
    }

    h1 {
      font-family: 'Cinzel', serif;
      font-size: 1.3rem;
      margin-bottom: 20px;
      color: var(--color-accent);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      text-align: center;
      letter-spacing: 3px;
      border-bottom: 2px solid rgba(212, 175, 55, 0.3);
      padding-bottom: 10px;
    }

    .character-card {
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(212, 175, 55, 0.2);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      position: relative;
      overflow: hidden;
    }

    .character-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, transparent, var(--color-archer), transparent);
    }

    .character-card.knight::before {
      background: linear-gradient(180deg, transparent, var(--color-knight), transparent);
    }

    .char-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
    }

    .char-icon {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .char-icon.archer {
      background: linear-gradient(135deg, #3498db, #2980b9);
    }

    .char-icon.knight {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
    }

    .char-name {
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      color: var(--color-text);
      letter-spacing: 1px;
    }

    .char-class {
      font-size: 0.75rem;
      color: rgba(244, 233, 216, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }

    .stat-label {
      color: rgba(244, 233, 216, 0.7);
      font-weight: 600;
    }

    .stat-value {
      color: var(--color-text);
      font-weight: 700;
      font-family: 'Cinzel', serif;
    }

    .combat-info {
      background: rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .combat-title {
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      color: var(--color-accent);
      margin-bottom: 12px;
      text-align: center;
      letter-spacing: 2px;
    }

    .legend {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .legend-title {
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      margin-bottom: 12px;
      color: var(--color-accent);
      text-align: center;
      letter-spacing: 1px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }

    .legend-color {
      width: 24px;
      height: 24px;
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-radius: 4px;
      flex-shrink: 0;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .instructions {
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(212, 175, 55, 0.05));
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 15px;
      font-size: 0.75rem;
      line-height: 1.7;
    }

    .instructions-title {
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      color: var(--color-accent);
      margin-bottom: 8px;
      letter-spacing: 1px;
    }

    .status-indicator {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-yes {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
      border: 1px solid rgba(46, 204, 113, 0.4);
    }

    .status-no {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
      border: 1px solid rgba(231, 76, 60, 0.4);
    }

    .hp-bar-container {
      margin-bottom: 12px;
    }

    .hp-bar {
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(212, 175, 55, 0.3);
      margin-bottom: 5px;
      position: relative;
    }

    .hp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #2ecc71, #27ae60);
      transition: width 0.5s ease;
      box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.3);
    }

    .archer-hp .hp-bar-fill {
      background: linear-gradient(90deg, #3498db, #2980b9);
    }

    .knight-hp .hp-bar-fill {
      background: linear-gradient(90deg, #e74c3c, #c0392b);
    }

    .hp-text {
      font-size: 0.75rem;
      color: rgba(244, 233, 216, 0.8);
      text-align: center;
      font-weight: 600;
    }

    .attack-button {
      width: 100%;
      padding: 12px;
      margin-top: 15px;
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border: 2px solid #c0392b;
      border-radius: 8px;
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
      transition: all 0.3s ease;
    }

    .attack-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
      background: linear-gradient(135deg, #ff5e4d, #e74c3c);
    }

    .attack-button:active:not(:disabled) {
      transform: translateY(0);
    }

    .attack-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .end-turn-button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      background: rgba(212, 175, 55, 0.2);
      border: 2px solid var(--color-accent);
      border-radius: 8px;
      color: var(--color-accent);
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
    }

    .end-turn-button:hover {
      background: rgba(212, 175, 55, 0.3);
      transform: translateX(3px);
    }

    .status-message {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      background: rgba(231, 76, 60, 0.2);
      border: 2px solid rgba(231, 76, 60, 0.5);
      border-radius: 8px;
      color: #e74c3c;
      font-family: 'Philosopher', sans-serif;
      font-size: 0.85rem;
      text-align: center;
      font-weight: 600;
    }

    .reset-button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      background: rgba(231, 76, 60, 0.1);
      border: 2px solid rgba(231, 76, 60, 0.5);
      border-radius: 8px;
      color: #e74c3c;
      font-family: 'Cinzel', serif;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
    }

    .reset-button:hover {
      background: rgba(231, 76, 60, 0.2);
      border-color: #e74c3c;
      transform: scale(1.02);
    }

    .reset-button:active {
      transform: scale(0.98);
    }

    .game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      animation: fadeIn 0.5s ease;
      backdrop-filter: blur(10px);
    }

    .game-over-card {
      background: linear-gradient(135deg, #3d2817 0%, #4a3420 100%);
      border: 3px solid var(--color-accent);
      border-radius: 16px;
      padding: 50px;
      text-align: center;
      max-width: 500px;
      box-shadow: 
        0 0 60px rgba(212, 175, 55, 0.4),
        0 20px 80px rgba(0, 0, 0, 0.8);
      animation: scaleIn 0.5s ease 0.2s backwards;
      position: relative;
    }

    .game-over-card::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, #d4af37, #f4e4c1, #d4af37);
      border-radius: 16px;
      z-index: -1;
      opacity: 0.5;
      animation: pulse 2s ease-in-out infinite;
    }

    .game-over-icon {
      font-size: 8rem;
      margin-bottom: 20px;
      animation: float 2s ease-in-out infinite;
      filter: drop-shadow(0 0 20px currentColor);
    }

    .game-over-icon.victory {
      color: #f1c40f;
    }

    .game-over-icon.defeat {
      color: #e74c3c;
    }

    .game-over-title {
      font-family: 'Cinzel', serif;
      font-size: 3rem;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 4px;
      text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.8),
        0 0 20px currentColor;
    }

    .game-over-title.victory {
      background: linear-gradient(135deg, #f1c40f, #f39c12);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over-title.defeat {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over-message {
      font-family: 'Philosopher', sans-serif;
      font-size: 1.2rem;
      color: var(--color-text);
      margin-bottom: 40px;
      line-height: 1.6;
      opacity: 0.9;
    }

    .play-again-button {
      background: linear-gradient(135deg, #f39c12, #f1c40f);
      border: 3px solid #f1c40f;
      border-radius: 12px;
      color: #2b1810;
      font-family: 'Cinzel', serif;
      font-size: 1.2rem;
      font-weight: 700;
      padding: 18px 40px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 
        0 6px 20px rgba(241, 196, 15, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .play-again-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.6s;
    }

    .play-again-button:hover::before {
      left: 100%;
    }

    .play-again-button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 
        0 10px 30px rgba(241, 196, 15, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    .play-again-button:active {
      transform: translateY(-1px) scale(1.02);
    }

    .splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 14, 39, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      backdrop-filter: blur(15px);
      animation: fadeIn 0.6s ease;
    }

    .splash-content {
      background: linear-gradient(135deg, #3d2817 0%, #4a3420 100%);
      border: 4px solid var(--color-accent);
      border-radius: 20px;
      padding: 50px 60px;
      max-width: 700px;
      text-align: center;
      box-shadow: 
        0 0 80px rgba(212, 175, 55, 0.5),
        0 20px 100px rgba(0, 0, 0, 0.9),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
      animation: scaleIn 0.6s ease 0.2s backwards;
    }

    .splash-content::before {
      content: '';
      position: absolute;
      top: -4px;
      left: -4px;
      right: -4px;
      bottom: -4px;
      background: linear-gradient(45deg, #d4af37, #f4e4c1, #d4af37);
      border-radius: 20px;
      z-index: -1;
      opacity: 0.6;
      animation: pulse 3s ease-in-out infinite;
    }

    .splash-header {
      margin-bottom: 30px;
    }

    .splash-icon {
      font-size: 5rem;
      margin-bottom: 15px;
      animation: float 3s ease-in-out infinite;
      filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.6));
    }

    .splash-title {
      font-family: 'Cinzel', serif;
      font-size: 3.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #f1c40f, #f39c12, #e67e22);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 40px rgba(241, 196, 15, 0.3);
      letter-spacing: 4px;
      line-height: 1.2;
    }

    .splash-subtitle {
      font-family: 'Philosopher', sans-serif;
      font-size: 1.3rem;
      color: rgba(244, 233, 216, 0.8);
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .splash-description {
      margin: 30px 0;
      line-height: 1.8;
      color: rgba(244, 233, 216, 0.9);
      font-size: 1.05rem;
    }

    .splash-description p {
      margin-bottom: 12px;
    }

    .splash-features {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 35px 0;
      padding: 25px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      border: 1px solid rgba(212, 175, 55, 0.2);
    }

    .feature-item {
      display: flex;
      align-items: center;
      gap: 15px;
      text-align: left;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .feature-item:hover {
      background: rgba(0, 0, 0, 0.4);
      transform: translateY(-2px);
    }

    .feature-icon {
      font-size: 2.5rem;
      flex-shrink: 0;
    }

    .feature-text {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .feature-text strong {
      color: var(--color-accent);
      font-family: 'Cinzel', serif;
      font-size: 1rem;
    }

    .feature-text span {
      color: rgba(244, 233, 216, 0.7);
      font-size: 0.85rem;
    }

    .splash-controls {
      background: rgba(212, 175, 55, 0.1);
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-radius: 10px;
      padding: 20px;
      margin: 30px 0;
      text-align: left;
    }

    .control-item {
      color: rgba(244, 233, 216, 0.85);
      margin-bottom: 10px;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .control-item:last-child {
      margin-bottom: 0;
    }

    .control-item strong {
      color: var(--color-accent);
      font-weight: 700;
    }

    .start-game-button {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border: 3px solid #c0392b;
      border-radius: 15px;
      color: white;
      font-family: 'Cinzel', serif;
      font-size: 1.5rem;
      font-weight: 700;
      padding: 20px 50px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      box-shadow: 
        0 8px 25px rgba(231, 76, 60, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      margin: 20px 0;
    }

    .start-game-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s;
    }

    .start-game-button:hover::before {
      left: 100%;
    }

    .start-game-button:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 
        0 12px 35px rgba(231, 76, 60, 0.7),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    .start-game-button:active {
      transform: translateY(-2px) scale(1.02);
    }

    .splash-footer {
      margin-top: 25px;
      font-size: 0.85rem;
      color: rgba(244, 233, 216, 0.6);
      font-style: italic;
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .damage-number {
      position: absolute;
      font-family: 'Cinzel', serif;
      font-size: 2rem;
      font-weight: 900;
      color: #ff3864;
      text-shadow: 
        2px 2px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        0 0 10px #ff3864;
      pointer-events: none;
      animation: damageFloat 1s ease-out forwards;
      z-index: 1000;
    }

    @keyframes damageFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(0.5);
      }
      50% {
        transform: translateY(-30px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateY(-60px) scale(1);
      }
    }

    @media (max-width: 1100px) {
      .container {
        flex-direction: column;
      }

      .info-panel {
        width: 100%;
        max-width: 600px;
      }
      
      .splash-content {
        padding: 40px;
        max-width: 90%;
      }
      
      .splash-title {
        font-size: 2.5rem;
      }
      
      .splash-features {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .splash-content {
        padding: 30px 25px;
      }
      
      .splash-title {
        font-size: 2rem;
      }
      
      .splash-icon {
        font-size: 3.5rem;
      }
      
      .start-game-button {
        font-size: 1.2rem;
        padding: 15px 35px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="game-board">
      <div class="board-title">‚öî CASTLE COURTYARD ‚öî</div>
      <canvas id="gameCanvas"></canvas>
    </div>
    
    <div class="info-panel">
      <h1>BATTLE STATUS</h1>
      
      <div class="character-card">
        <div class="char-header">
          <div class="char-icon archer">üèπ</div>
          <div>
            <div class="char-name">Elara</div>
            <div class="char-class">Archer</div>
          </div>
        </div>
        <div class="hp-bar-container">
          <div class="hp-bar archer-hp" id="archerHpBar">
            <div class="hp-bar-fill" style="width: 100%"></div>
          </div>
          <div class="hp-text"><span id="archerHp">50</span> / 50 HP</div>
        </div>
        <div class="stat-row">
          <span class="stat-label">Position:</span>
          <span class="stat-value" id="archerPos">Drag to move</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Movement:</span>
          <span class="stat-value"><span id="archerMovement">30</span> / 30 ft</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Range:</span>
          <span class="stat-value">40 ft (Longbow)</span>
        </div>
      </div>

      <div class="character-card knight">
        <div class="char-header">
          <div class="char-icon knight">‚öîÔ∏è</div>
          <div>
            <div class="char-name">Sir Gareth</div>
            <div class="char-class">Knight (AI)</div>
          </div>
        </div>
        <div class="hp-bar-container">
          <div class="hp-bar knight-hp" id="knightHpBar">
            <div class="hp-bar-fill" style="width: 100%"></div>
          </div>
          <div class="hp-text"><span id="knightHp">80</span> / 80 HP</div>
        </div>
        <div class="stat-row">
          <span class="stat-label">Position:</span>
          <span class="stat-value" id="knightPos">(18, 12)</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Movement:</span>
          <span class="stat-value">25 ft</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Range:</span>
          <span class="stat-value">5 ft (Melee)</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Strategy:</span>
          <span class="stat-value">Stealth & Ambush</span>
        </div>
      </div>

      <div class="combat-info">
        <div class="combat-title">TACTICAL ANALYSIS</div>
        
        <div class="stat-row">
          <span class="stat-label">Current Turn:</span>
          <span class="stat-value" id="currentTurn">Elara (Archer)</span>
        </div>
        
        <div class="stat-row">
          <span class="stat-label">Distance:</span>
          <span class="stat-value" id="distance">---</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">In Range:</span>
          <span id="inRange">---</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Line of Sight:</span>
          <span id="los">---</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Path Distance:</span>
          <span class="stat-value" id="pathLength">---</span>
        </div>
        
        <button id="attackBtn" class="attack-button" style="display: none;">
          ‚öîÔ∏è ATTACK
        </button>
        
        <div id="attackedIndicator" class="status-message" style="display: none;">
          ‚öîÔ∏è Already attacked this turn
        </div>
        
        <button id="endTurnBtn" class="end-turn-button">
          END TURN ‚Üí
        </button>
        
        <button id="resetBtn" class="reset-button">
          üîÑ RESET BATTLE
        </button>
      </div>

      <div class="legend">
        <div class="legend-title">TERRAIN INDICATORS</div>
        <div class="legend-item">
          <div class="legend-color" style="background: var(--color-movement);"></div>
          <span>Movement Range (Blue)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: var(--color-attack);"></div>
          <span>Attack Range (Red)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: var(--color-los);"></div>
          <span>Line of Sight (Gold)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: var(--color-path);"></div>
          <span>Pathfinding (Purple)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #5c4a3a;"></div>
          <span>Castle Walls</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #2d4a2d;"></div>
          <span>Trees (Blocks LOS)</span>
        </div>
      </div>

      <div class="instructions">
        <div class="instructions-title">INSTRUCTIONS</div>
        ‚Ä¢ <strong>You control Elara (Archer)</strong><br>
        ‚Ä¢ <strong>Knight has AI:</strong> Uses stealth tactics to close distance<br>
        ‚Ä¢ Drag Elara to move on your turn<br>
        ‚Ä¢ Movement is deducted as you move (30 ft total)<br>
        ‚Ä¢ Attack once per turn when in range + LOS<br>
        ‚Ä¢ Can move before AND after attacking<br>
        ‚Ä¢ Click "End Turn" when done<br>
        ‚Ä¢ First to 0 HP loses
      </div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
    <div class="game-over-card">
      <div class="game-over-icon" id="gameOverIcon">
        <!-- Icon will be inserted by JS -->
      </div>
      <h2 class="game-over-title" id="gameOverTitle">VICTORY!</h2>
      <p class="game-over-message" id="gameOverMessage">
        You have defeated Sir Gareth in honorable combat!
      </p>
      <button id="playAgainBtn" class="play-again-button">
        ‚öîÔ∏è PLAY AGAIN
      </button>
    </div>
  </div>

  <!-- Splash Screen -->
  <div id="splashScreen" class="splash-screen">
    <div class="splash-content">
      <div class="splash-header">
        <div class="splash-icon">‚öîÔ∏è</div>
        <h1 class="splash-title">CASTLE COURTYARD</h1>
        <div class="splash-subtitle">Tactical Combat</div>
      </div>
      
      <div class="splash-description">
        <p>Face off against Sir Gareth, a cunning knight who uses stealth and ambush tactics.</p>
        <p>Use your longbow and superior range to defeat him before he closes the distance!</p>
      </div>
      
      <div class="splash-features">
        <div class="feature-item">
          <div class="feature-icon">üèπ</div>
          <div class="feature-text">
            <strong>Elara - Archer</strong>
            <span>40 ft range, 30 ft movement</span>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-icon">‚öîÔ∏è</div>
          <div class="feature-text">
            <strong>Sir Gareth - Knight</strong>
            <span>5 ft melee, 25 ft movement</span>
          </div>
        </div>
      </div>
      
      <div class="splash-controls">
        <div class="control-item">‚Ä¢ <strong>Drag</strong> to move your character</div>
        <div class="control-item">‚Ä¢ <strong>Attack</strong> when in range with line of sight</div>
        <div class="control-item">‚Ä¢ <strong>End Turn</strong> to pass to opponent</div>
      </div>
      
      <button id="startGameBtn" class="start-game-button">
        ‚öîÔ∏è BEGIN BATTLE
      </button>
      
      <div class="splash-footer">
        First to 0 HP loses ‚Ä¢ Random starting positions ‚Ä¢ AI opponent
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const GRID_WIDTH = 25;
    const GRID_HEIGHT = 20;
    const CELL_SIZE = 45;
    
    canvas.width = GRID_WIDTH * CELL_SIZE;
    canvas.height = GRID_HEIGHT * CELL_SIZE;
    
    // Terrain types: 0 = grass, 1 = wall, 2 = tree, 3 = stone floor, 4 = building
    let grid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
    
    // Sound effects (using Web Audio API for procedural sounds)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      switch(type) {
        case 'move':
          oscillator.frequency.value = 300;
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
          break;
        case 'arrow':
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.3);
          gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.3);
          break;
        case 'sword':
          oscillator.type = 'square';
          oscillator.frequency.value = 150;
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
          break;
        case 'hit':
          oscillator.type = 'sawtooth';
          oscillator.frequency.value = 100;
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.15);
          break;
        case 'victory':
          [400, 500, 600, 800].forEach((freq, i) => {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.15 + 0.3);
            osc.start(audioContext.currentTime + i * 0.15);
            osc.stop(audioContext.currentTime + i * 0.15 + 0.3);
          });
          break;
        case 'defeat':
          [600, 500, 400, 300].forEach((freq, i) => {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.15 + 0.3);
            osc.start(audioContext.currentTime + i * 0.15);
            osc.stop(audioContext.currentTime + i * 0.15 + 0.3);
          });
          break;
      }
    }
    
    // Generate random courtyard layout
    function generateCourtyard() {
      // Reset grid
      grid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
      
      // Outer walls with random gate positions
      const gateTop = 8 + Math.floor(Math.random() * 6);
      const gateBottom = 8 + Math.floor(Math.random() * 6);
      
      for (let x = 0; x < GRID_WIDTH; x++) {
        if (x < gateTop || x > gateTop + 5) {
          grid[0][x] = 1;
          grid[1][x] = 1;
        }
      }
      
      for (let x = 0; x < GRID_WIDTH; x++) {
        if (x < gateBottom || x > gateBottom + 5) {
          grid[GRID_HEIGHT - 1][x] = 1;
          grid[GRID_HEIGHT - 2][x] = 1;
        }
      }
      
      // Side walls
      for (let y = 2; y < GRID_HEIGHT - 2; y++) {
        grid[y][0] = 1;
        grid[y][1] = 1;
        grid[y][GRID_WIDTH - 1] = 1;
        grid[y][GRID_WIDTH - 2] = 1;
      }
      
      // Random buildings (1-2 buildings)
      const numBuildings = 1 + Math.floor(Math.random() * 2);
      for (let b = 0; b < numBuildings; b++) {
        const bx = 3 + Math.floor(Math.random() * (GRID_WIDTH - 10));
        const by = 3 + Math.floor(Math.random() * (GRID_HEIGHT - 10));
        const bw = 4 + Math.floor(Math.random() * 3);
        const bh = 4 + Math.floor(Math.random() * 3);
        
        for (let y = by; y < by + bh && y < GRID_HEIGHT - 2; y++) {
          for (let x = bx; x < bx + bw && x < GRID_WIDTH - 2; x++) {
            if (y === by || y === by + bh - 1 || x === bx || x === bx + bw - 1) {
              grid[y][x] = 1;
            } else {
              grid[y][x] = 4;
            }
          }
        }
        // Add entrance
        if (Math.random() < 0.5) {
          grid[by + bh - 1][bx + Math.floor(bw / 2)] = 3;
        } else {
          grid[by + Math.floor(bh / 2)][bx + bw - 1] = 3;
        }
      }
      
      // Random trees (12-20 trees)
      const numTrees = 12 + Math.floor(Math.random() * 9);
      for (let t = 0; t < numTrees; t++) {
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 20) {
          attempts++;
          const x = 2 + Math.floor(Math.random() * (GRID_WIDTH - 4));
          const y = 2 + Math.floor(Math.random() * (GRID_HEIGHT - 4));
          if (grid[y][x] === 0) {
            grid[y][x] = 2;
            placed = true;
          }
        }
      }
      
      // Stone pathways
      const numPaths = 1 + Math.floor(Math.random() * 2);
      for (let p = 0; p < numPaths; p++) {
        const px = 3 + Math.floor(Math.random() * (GRID_WIDTH - 8));
        const py = 3 + Math.floor(Math.random() * (GRID_HEIGHT - 8));
        const pw = 2 + Math.floor(Math.random() * 3);
        const ph = 3 + Math.floor(Math.random() * 4);
        
        for (let y = py; y < py + ph && y < GRID_HEIGHT - 2; y++) {
          for (let x = px; x < px + pw && x < GRID_WIDTH - 2; x++) {
            if (grid[y][x] === 0) {
              grid[y][x] = 3;
            }
          }
        }
      }
    }
    
    // Create initial castle courtyard environment
    generateCourtyard();
    
    let archer = { x: 8, y: 10, hp: 50, maxHp: 50, startX: 8, startY: 10 };
    let knight = { x: 18, y: 12, hp: 80, maxHp: 80, startX: 18, startY: 12 };
    let isDragging = false;
    let dragTarget = null; // Track which character is being dragged
    let currentTurn = 'archer'; // Track whose turn it is
    let isAnimating = false; // Prevent actions during animations
    let aiThinking = false; // Track if AI is processing
    let movementUsedThisTurn = 0; // Track movement used
    let hasAttacked = false; // Track if attack used this turn
    
    const ARCHER_MOVEMENT = 6;  // 30 feet
    const ARCHER_RANGE = 8;     // 40 feet (longbow)
    const KNIGHT_MOVEMENT = 5;  // 25 feet
    const KNIGHT_RANGE = 1;     // 5 feet (melee)
    
    const ARCHER_DAMAGE = { min: 8, max: 15 }; // 1d8+7 damage
    const KNIGHT_DAMAGE = { min: 10, max: 18 }; // 1d8+9 damage
    
    // Find random starting positions
    function findRandomStartingPositions() {
      let archerPos = null;
      let knightPos = null;
      let attempts = 0;
      const maxAttempts = 100;
      
      // Find a position for the knight in cover
      while (!knightPos && attempts < maxAttempts) {
        attempts++;
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        
        // Check if position is valid (not a wall/tree)
        if (grid[y] && grid[y][x] !== undefined && grid[y][x] !== 1 && grid[y][x] !== 2) {
          // Check if position has cover (adjacent wall or tree)
          const hasCover = checkForCover({ x, y });
          
          if (hasCover) {
            knightPos = { x, y };
          }
        }
      }
      
      // Fallback if no cover found
      if (!knightPos) {
        knightPos = { x: 18, y: 12 };
      }
      
      // Find a position for the archer in open space, away from knight
      attempts = 0;
      while (!archerPos && attempts < maxAttempts) {
        attempts++;
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        
        // Check if position is valid AND not same as knight
        if (grid[y] && grid[y][x] !== undefined && grid[y][x] !== 1 && grid[y][x] !== 2 &&
            !(x === knightPos.x && y === knightPos.y)) {
          const distance = getDistance({ x, y }, knightPos);
          
          // Archer should be at least 8 squares away
          if (distance >= 8 && distance <= 15) {
            // Prefer open positions (not in cover)
            const inCover = checkForCover({ x, y });
            if (!inCover) {
              archerPos = { x, y };
            }
          }
        }
      }
      
      // Fallback if no position found
      if (!archerPos) {
        // Find any valid position away from knight
        for (let y = 2; y < GRID_HEIGHT - 2 && !archerPos; y++) {
          for (let x = 2; x < GRID_WIDTH - 2 && !archerPos; x++) {
            if (grid[y][x] === 0 && !(x === knightPos.x && y === knightPos.y)) {
              const dist = getDistance({ x, y }, knightPos);
              if (dist >= 8) {
                archerPos = { x, y };
              }
            }
          }
        }
      }
      
      return { archerPos, knightPos };
    }
    
    function checkForCover(pos) {
      // Check if position has adjacent walls or trees
      const neighbors = [
        { x: pos.x + 1, y: pos.y },
        { x: pos.x - 1, y: pos.y },
        { x: pos.x, y: pos.y + 1 },
        { x: pos.x, y: pos.y - 1 },
        { x: pos.x + 1, y: pos.y + 1 },
        { x: pos.x - 1, y: pos.y - 1 },
        { x: pos.x + 1, y: pos.y - 1 },
        { x: pos.x - 1, y: pos.y + 1 },
      ];
      
      for (let n of neighbors) {
        if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT) {
          if (grid[n.y] && grid[n.y][n.x] && (grid[n.y][n.x] === 1 || grid[n.y][n.x] === 2)) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    function randomizeStartingTurn() {
      return Math.random() < 0.5 ? 'archer' : 'knight';
    }
    
    // Bresenham's Line Algorithm
    function hasLineOfSight(start, end) {
      let x0 = Math.floor(start.x);
      let y0 = Math.floor(start.y);
      let x1 = Math.floor(end.x);
      let y1 = Math.floor(end.y);
      
      // Bounds check
      if (x0 < 0 || x0 >= GRID_WIDTH || y0 < 0 || y0 >= GRID_HEIGHT ||
          x1 < 0 || x1 >= GRID_WIDTH || y1 < 0 || y1 >= GRID_HEIGHT) {
        return false;
      }
      
      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1;
      const sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      
      while (true) {
        // Bounds check each step
        if (x0 < 0 || x0 >= GRID_WIDTH || y0 < 0 || y0 >= GRID_HEIGHT) {
          return false;
        }
        
        if ((x0 !== Math.floor(start.x) || y0 !== Math.floor(start.y)) && 
            (x0 !== Math.floor(end.x) || y0 !== Math.floor(end.y)) && 
            grid[y0] && grid[y0][x0] && (grid[y0][x0] === 1 || grid[y0][x0] === 2)) {
          return false;
        }
        
        if (x0 === x1 && y0 === y1) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x0 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y0 += sy;
        }
      }
      
      return true;
    }
    
    function getLinePoints(start, end) {
      const points = [];
      let x0 = Math.floor(start.x);
      let y0 = Math.floor(start.y);
      let x1 = Math.floor(end.x);
      let y1 = Math.floor(end.y);
      
      // Bounds check
      if (x0 < 0 || x0 >= GRID_WIDTH || y0 < 0 || y0 >= GRID_HEIGHT ||
          x1 < 0 || x1 >= GRID_WIDTH || y1 < 0 || y1 >= GRID_HEIGHT) {
        return points;
      }
      
      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1;
      const sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      
      while (true) {
        // Bounds check each step
        if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
          points.push({ x: x0, y: y0 });
        }
        
        if (x0 === x1 && y0 === y1) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x0 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y0 += sy;
        }
        
        // Safety check to prevent infinite loops
        if (Math.abs(x0) > GRID_WIDTH * 2 || Math.abs(y0) > GRID_HEIGHT * 2) {
          break;
        }
      }
      
      return points;
    }
    
    function getDistance(start, end) {
      const dx = Math.abs(end.x - start.x);
      const dy = Math.abs(end.y - start.y);
      return Math.max(dx, dy);
    }
    
    function getMovementRange(start, range) {
      const visited = new Set();
      const queue = [{ x: Math.round(start.x), y: Math.round(start.y), cost: 0 }];
      const reachable = [];
      
      while (queue.length > 0) {
        const current = queue.shift();
        const key = `${current.x},${current.y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        // Bounds check
        if (current.x < 0 || current.x >= GRID_WIDTH || current.y < 0 || current.y >= GRID_HEIGHT) {
          continue;
        }
        
        if (current.cost <= range) {
          reachable.push({ x: current.x, y: current.y, cost: current.cost });
        }
        
        if (current.cost >= range) continue;
        
        const neighbors = [
          { x: current.x + 1, y: current.y },
          { x: current.x - 1, y: current.y },
          { x: current.x, y: current.y + 1 },
          { x: current.x, y: current.y - 1 },
          { x: current.x + 1, y: current.y + 1 },
          { x: current.x + 1, y: current.y - 1 },
          { x: current.x - 1, y: current.y + 1 },
          { x: current.x - 1, y: current.y - 1 },
        ];
        
        for (let n of neighbors) {
          if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT && 
              grid[n.y] && grid[n.y][n.x] !== undefined &&
              grid[n.y][n.x] !== 1 && grid[n.y][n.x] !== 2) {
            queue.push({ ...n, cost: current.cost + 1 });
          }
        }
      }
      
      return reachable;
    }
    
    function findPath(start, end) {
      // Bounds check and round positions
      const startX = Math.round(start.x);
      const startY = Math.round(start.y);
      const endX = Math.round(end.x);
      const endY = Math.round(end.y);
      
      if (startX < 0 || startX >= GRID_WIDTH || startY < 0 || startY >= GRID_HEIGHT ||
          endX < 0 || endX >= GRID_WIDTH || endY < 0 || endY >= GRID_HEIGHT) {
        return [];
      }
      
      if (grid[endY] && grid[endY][endX] && (grid[endY][endX] === 1 || grid[endY][endX] === 2)) {
        return [];
      }
      
      const openSet = [{ x: startX, y: startY, g: 0, h: getDistance({x: startX, y: startY}, {x: endX, y: endY}), f: getDistance({x: startX, y: startY}, {x: endX, y: endY}), parent: null }];
      const closedSet = new Set();
      
      while (openSet.length > 0) {
        openSet.sort((a, b) => a.f - b.f);
        const current = openSet.shift();
        const key = `${current.x},${current.y}`;
        
        if (current.x === endX && current.y === endY) {
          const path = [];
          let node = current;
          while (node) {
            path.unshift({ x: node.x, y: node.y });
            node = node.parent;
          }
          return path;
        }
        
        closedSet.add(key);
        
        const neighbors = [
          { x: current.x + 1, y: current.y },
          { x: current.x - 1, y: current.y },
          { x: current.x, y: current.y + 1 },
          { x: current.x, y: current.y - 1 },
          { x: current.x + 1, y: current.y + 1 },
          { x: current.x + 1, y: current.y - 1 },
          { x: current.x - 1, y: current.y + 1 },
          { x: current.x - 1, y: current.y - 1 },
        ];
        
        for (let n of neighbors) {
          const nKey = `${n.x},${n.y}`;
          if (n.x < 0 || n.x >= GRID_WIDTH || n.y < 0 || n.y >= GRID_HEIGHT ||
              !grid[n.y] || grid[n.y][n.x] === undefined ||
              grid[n.y][n.x] === 1 || grid[n.y][n.x] === 2 || closedSet.has(nKey)) {
            continue;
          }
          
          const g = current.g + 1;
          const h = getDistance(n, {x: endX, y: endY});
          const f = g + h;
          
          const existing = openSet.find(node => node.x === n.x && node.y === n.y);
          if (!existing || g < existing.g) {
            if (existing) {
              existing.g = g;
              existing.f = f;
              existing.parent = current;
            } else {
              openSet.push({ ...n, g, h, f, parent: current });
            }
          }
        }
      }
      
      return [];
    }
    
    // Attack animation functions
    function performAttack(attacker, target) {
      if (isAnimating) return;
      isAnimating = true;
      
      const attackerName = attacker === archer ? 'archer' : 'knight';
      const targetName = target === archer ? 'archer' : 'knight';
      const damage = attackerName === 'archer' ? 
        Math.floor(Math.random() * (ARCHER_DAMAGE.max - ARCHER_DAMAGE.min + 1)) + ARCHER_DAMAGE.min :
        Math.floor(Math.random() * (KNIGHT_DAMAGE.max - KNIGHT_DAMAGE.min + 1)) + KNIGHT_DAMAGE.min;
      
      if (attackerName === 'archer') {
        animateArrowAttack(attacker, target, damage);
      } else {
        animateMeleeAttack(attacker, target, damage);
      }
    }
    
    function animateArrowAttack(attacker, target, damage) {
      playSound('arrow'); // Arrow sound effect
      
      const startX = attacker.x * CELL_SIZE + CELL_SIZE / 2;
      const startY = attacker.y * CELL_SIZE + CELL_SIZE / 2;
      const endX = target.x * CELL_SIZE + CELL_SIZE / 2;
      const endY = target.y * CELL_SIZE + CELL_SIZE / 2;
      
      let progress = 0;
      const duration = 500; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        progress = Math.min(elapsed / duration, 1);
        
        const currentX = startX + (endX - startX) * progress;
        const currentY = startY + (endY - startY) * progress - Math.sin(progress * Math.PI) * 30;
        
        draw();
        
        // Draw arrow projectile
        ctx.save();
        ctx.translate(currentX, currentY);
        const angle = Math.atan2(endY - startY, endX - startX);
        ctx.rotate(angle);
        
        // Arrow shaft
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(15, 0);
        ctx.stroke();
        
        // Arrow head
        ctx.fillStyle = '#7f8c8d';
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(10, -4);
        ctx.lineTo(10, 4);
        ctx.closePath();
        ctx.fill();
        
        // Arrow fletching
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(-12, -3);
        ctx.lineTo(-12, 3);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          playSound('hit'); // Hit sound effect
          applyDamage(target, damage);
          showDamageNumber(target, damage);
          hasAttacked = true;
          setTimeout(() => {
            isAnimating = false;
            updateUI();
            draw();
          }, 1000);
        }
      }
      
      animate();
    }
    
    function animateMeleeAttack(attacker, target, damage) {
      playSound('sword'); // Sword sound effect
      
      const originalX = attacker.x;
      const originalY = attacker.y;
      
      let progress = 0;
      const duration = 300;
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        progress = Math.min(elapsed / duration, 1);
        
        // Lunge forward and back
        const lungeProgress = progress < 0.5 ? progress * 2 : (1 - progress) * 2;
        const offsetX = (target.x - attacker.x) * lungeProgress * 0.3;
        const offsetY = (target.y - attacker.y) * lungeProgress * 0.3;
        
        draw();
        
        // Draw sword slash effect at peak
        if (progress > 0.3 && progress < 0.7) {
          const slashProgress = (progress - 0.3) / 0.4;
          ctx.save();
          ctx.translate(target.x * CELL_SIZE + CELL_SIZE / 2, target.y * CELL_SIZE + CELL_SIZE / 2);
          ctx.rotate(slashProgress * Math.PI);
          ctx.strokeStyle = `rgba(255, 255, 255, ${1 - slashProgress})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(0, 0, 20 + slashProgress * 20, 0, Math.PI);
          ctx.stroke();
          ctx.restore();
        }
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          playSound('hit'); // Hit sound effect
          applyDamage(target, damage);
          showDamageNumber(target, damage);
          hasAttacked = true;
          setTimeout(() => {
            isAnimating = false;
            updateUI();
            draw();
          }, 1000);
        }
      }
      
      animate();
    }
    
    function applyDamage(target, damage) {
      target.hp = Math.max(0, target.hp - damage);
      updateUI();
      
      // Check for victory
      if (target.hp <= 0) {
        setTimeout(() => {
          showGameOver(target === knight);
        }, 1000);
      }
    }
    
    function showGameOver(playerWon) {
      const overlay = document.getElementById('gameOverOverlay');
      const icon = document.getElementById('gameOverIcon');
      const title = document.getElementById('gameOverTitle');
      const message = document.getElementById('gameOverMessage');
      
      if (playerWon) {
        playSound('victory'); // Victory fanfare
        // Victory
        icon.innerHTML = 'üëë';
        icon.className = 'game-over-icon victory';
        title.textContent = 'VICTORY!';
        title.className = 'game-over-title victory';
        message.textContent = 'You have defeated Sir Gareth in honorable combat! The castle courtyard is yours.';
      } else {
        playSound('defeat'); // Defeat sound
        // Defeat
        icon.innerHTML = 'üíÄ';
        icon.className = 'game-over-icon defeat';
        title.textContent = 'DEFEAT';
        title.className = 'game-over-title defeat';
        message.textContent = 'Sir Gareth has bested you in battle. The knight\'s tactical prowess proved superior.';
      }
      
      overlay.style.display = 'flex';
    }
    
    function hideGameOver() {
      document.getElementById('gameOverOverlay').style.display = 'none';
    }
    
    function showSplashScreen() {
      document.getElementById('splashScreen').style.display = 'flex';
    }
    
    function hideSplashScreen() {
      const splash = document.getElementById('splashScreen');
      splash.style.opacity = '0';
      splash.style.transition = 'opacity 0.5s ease';
      setTimeout(() => {
        splash.style.display = 'none';
      }, 500);
    }
    
    function showTurnIndicator(turn) {
      // Create a temporary indicator showing who goes first
      const indicator = document.createElement('div');
      indicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(61, 40, 23, 0.95), rgba(74, 52, 32, 0.95));
        border: 3px solid ${turn === 'archer' ? '#3498db' : '#e74c3c'};
        border-radius: 12px;
        padding: 30px 50px;
        font-family: 'Cinzel', serif;
        font-size: 1.5rem;
        color: ${turn === 'archer' ? '#3498db' : '#e74c3c'};
        z-index: 1500;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        animation: scaleIn 0.3s ease;
      `;
      indicator.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 10px;">${turn === 'archer' ? 'üèπ' : '‚öîÔ∏è'}</div>
        <div>${turn === 'archer' ? 'ELARA' : 'SIR GARETH'}</div>
        <div style="font-size: 1rem; opacity: 0.7; margin-top: 5px;">goes first</div>
      `;
      
      document.body.appendChild(indicator);
      
      setTimeout(() => {
        indicator.style.opacity = '0';
        indicator.style.transform = 'translate(-50%, -50%) scale(0.9)';
        indicator.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          indicator.remove();
        }, 300);
      }, 2000);
    }
    
    function showDamageNumber(target, damage) {
      const x = target.x * CELL_SIZE + CELL_SIZE / 2;
      const y = target.y * CELL_SIZE + CELL_SIZE / 2;
      
      const damageEl = document.createElement('div');
      damageEl.className = 'damage-number';
      damageEl.textContent = `-${damage}`;
      damageEl.style.left = (canvas.offsetLeft + x) + 'px';
      damageEl.style.top = (canvas.offsetTop + y) + 'px';
      
      document.body.appendChild(damageEl);
      
      setTimeout(() => {
        damageEl.remove();
      }, 1000);
    }
    
    function endTurn() {
      // Reset movement tracking for next turn
      movementUsedThisTurn = 0;
      hasAttacked = false;
      
      // Update start positions
      archer.startX = Math.round(archer.x);
      archer.startY = Math.round(archer.y);
      knight.startX = Math.round(knight.x);
      knight.startY = Math.round(knight.y);
      delete archer.startPos;
      delete knight.startPos;
      
      currentTurn = currentTurn === 'archer' ? 'knight' : 'archer';
      updateUI();
      draw();
      
      // Trigger AI turn if it's the knight's turn
      if (currentTurn === 'knight') {
        setTimeout(() => {
          knightAI();
        }, 800); // Small delay so player can see turn change
      }
    }
    
    // Knight AI - Tactical stealth approach
    function knightAI() {
      if (aiThinking || isAnimating) return;
      aiThinking = true;
      
      const distance = getDistance(knight, archer);
      const los = hasLineOfSight(knight, archer);
      const inMeleeRange = distance <= KNIGHT_RANGE;
      
      // Priority 1: Attack if in range and has LOS
      if (inMeleeRange && los) {
        setTimeout(() => {
          performAttack(knight, archer);
          // Wait for attack animation to finish, then end turn
          setTimeout(() => {
            aiThinking = false;
            endTurn();
          }, 1500);
        }, 500);
        return;
      }
      
      // Priority 2: Move tactically
      const bestMove = findBestKnightMove();
      
      if (bestMove) {
        animateKnightMovement(bestMove, () => {
          knight.x = bestMove.x;
          knight.y = bestMove.y;
          
          // After moving, check if we can attack
          const newDistance = getDistance(knight, archer);
          const newLos = hasLineOfSight(knight, archer);
          
          if (newDistance <= KNIGHT_RANGE && newLos) {
            setTimeout(() => {
              performAttack(knight, archer);
              // Wait for attack animation to finish, then end turn
              setTimeout(() => {
                aiThinking = false;
                endTurn();
              }, 1500);
            }, 500);
          } else {
            // End turn without attacking
            setTimeout(() => {
              aiThinking = false;
              endTurn();
            }, 800);
          }
        });
      } else {
        // No good move found, just end turn
        setTimeout(() => {
          aiThinking = false;
          endTurn();
        }, 800);
      }
    }
    
    function findBestKnightMove() {
      const movementRange = getMovementRange(knight, KNIGHT_MOVEMENT);
      let bestMove = null;
      let bestScore = -Infinity;
      
      for (let move of movementRange) {
        // Don't consider current position
        if (move.x === knight.x && move.y === knight.y) continue;
        
        const score = evaluateKnightPosition(move);
        
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      
      return bestMove;
    }
    
    function evaluateKnightPosition(pos) {
      let score = 0;
      
      // Ensure position is within bounds
      if (pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT) {
        return -10000; // Invalid position
      }
      
      const distanceToArcher = getDistance(pos, archer);
      const losToArcher = hasLineOfSight(pos, archer);
      
      // Strongly prefer positions that get us into melee range
      if (distanceToArcher <= KNIGHT_RANGE) {
        score += 1000; // Highest priority - melee range!
        if (losToArcher) {
          score += 500; // Can attack immediately!
        }
      } else {
        // Get closer to archer (but not too directly)
        const closerBonus = (ARCHER_RANGE - distanceToArcher) * 10;
        score += closerBonus;
      }
      
      // Hide from archer's line of sight (stealth tactic)
      if (!losToArcher) {
        score += 200; // Good bonus for being hidden
      } else if (distanceToArcher > ARCHER_RANGE) {
        // If visible but out of archer's range, that's okay
        score += 50;
      } else {
        // Visible and in archer's range - dangerous!
        score -= 300;
      }
      
      // Prefer cover positions (near walls/trees but not blocked)
      const coverScore = evaluateCover(pos);
      score += coverScore;
      
      // Slightly prefer positions that have escape routes
      const mobilityScore = countAccessibleNeighbors(pos) * 5;
      score += mobilityScore;
      
      // Pathfinding - prefer positions with clear path to archer
      const pathToArcher = findPath(pos, archer);
      if (pathToArcher.length > 0) {
        score += 20; // Bonus for accessible position
        
        // Prefer positions closer along the path
        const pathLength = pathToArcher.length;
        score -= pathLength * 2; // Closer is better
      } else {
        score -= 500; // Heavily penalize unreachable positions
      }
      
      return score;
    }
    
    function evaluateCover(pos) {
      let coverScore = 0;
      
      // Bounds check
      if (pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT) {
        return -1000;
      }
      
      // Check adjacent tiles for walls/trees (cover)
      const neighbors = [
        { x: pos.x + 1, y: pos.y },
        { x: pos.x - 1, y: pos.y },
        { x: pos.x, y: pos.y + 1 },
        { x: pos.x, y: pos.y - 1 },
      ];
      
      for (let n of neighbors) {
        if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT) {
          if (grid[n.y] && grid[n.y][n.x] && (grid[n.y][n.x] === 1 || grid[n.y][n.x] === 2)) {
            // Check if this cover is between knight and archer
            const coverBlocksLOS = !hasLineOfSight(
              { x: pos.x, y: pos.y }, 
              archer
            );
            
            if (coverBlocksLOS) {
              coverScore += 30; // Good cover
            } else {
              coverScore += 5; // Some cover, but not blocking LOS
            }
          }
        }
      }
      
      return coverScore;
    }
    
    function countAccessibleNeighbors(pos) {
      let count = 0;
      const neighbors = [
        { x: pos.x + 1, y: pos.y },
        { x: pos.x - 1, y: pos.y },
        { x: pos.x, y: pos.y + 1 },
        { x: pos.x, y: pos.y - 1 },
        { x: pos.x + 1, y: pos.y + 1 },
        { x: pos.x - 1, y: pos.y - 1 },
        { x: pos.x + 1, y: pos.y - 1 },
        { x: pos.x - 1, y: pos.y + 1 },
      ];
      
      for (let n of neighbors) {
        if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT &&
            grid[n.y][n.x] !== 1 && grid[n.y][n.x] !== 2) {
          count++;
        }
      }
      
      return count;
    }
    
    function animateKnightMovement(targetPos, onComplete) {
      const startX = knight.x;
      const startY = knight.y;
      
      // Round starting position to ensure we're on grid
      knight.x = Math.round(startX);
      knight.y = Math.round(startY);
      
      const path = findPath({ x: Math.round(startX), y: Math.round(startY) }, targetPos);
      
      if (path.length <= 1) {
        knight.x = targetPos.x;
        knight.y = targetPos.y;
        onComplete();
        return;
      }
      
      let currentStep = 0;
      const stepDuration = 200; // ms per step
      
      function moveStep() {
        if (currentStep >= path.length - 1) {
          knight.x = Math.round(knight.x);
          knight.y = Math.round(knight.y);
          onComplete();
          return;
        }
        
        currentStep++;
        const step = path[currentStep];
        
        // Animate movement
        const startPos = { x: Math.round(knight.x), y: Math.round(knight.y) };
        const endPos = step;
        let progress = 0;
        const animStart = Date.now();
        
        function animate() {
          const elapsed = Date.now() - animStart;
          progress = Math.min(elapsed / stepDuration, 1);
          
          // Smooth interpolation
          const eased = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          knight.x = startPos.x + (endPos.x - startPos.x) * eased;
          knight.y = startPos.y + (endPos.y - startPos.y) * eased;
          
          draw();
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            knight.x = Math.round(knight.x);
            knight.y = Math.round(knight.y);
            setTimeout(moveStep, 100);
          }
        }
        
        animate();
      }
      
      moveStep();
    }
    
    function drawTerrain(x, y, type) {
      const px = x * CELL_SIZE;
      const py = y * CELL_SIZE;
      
      switch(type) {
        case 0: // Grass
          const grassShade = (x + y) % 3;
          ctx.fillStyle = grassShade === 0 ? '#4a6741' : grassShade === 1 ? '#5d7f54' : '#3d5836';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          
          // Grass texture
          for (let i = 0; i < 5; i++) {
            ctx.strokeStyle = `rgba(93, 127, 84, ${0.2 + Math.random() * 0.2})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px + Math.random() * CELL_SIZE, py + Math.random() * CELL_SIZE);
            ctx.lineTo(px + Math.random() * CELL_SIZE, py + Math.random() * CELL_SIZE);
            ctx.stroke();
          }
          break;
          
        case 1: // Wall
          ctx.fillStyle = '#5c4a3a';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          
          // Stone texture
          ctx.fillStyle = '#6b5d4d';
          ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
          
          // Mortar lines
          ctx.strokeStyle = '#4a3d2f';
          ctx.lineWidth = 2;
          ctx.strokeRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
          
          // Highlight
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(px, py, CELL_SIZE, 3);
          ctx.fillRect(px, py, 3, CELL_SIZE);
          
          // Shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(px, py + CELL_SIZE - 3, CELL_SIZE, 3);
          ctx.fillRect(px + CELL_SIZE - 3, py, 3, CELL_SIZE);
          break;
          
        case 2: // Tree
          ctx.fillStyle = '#4a6741';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          
          // Tree trunk
          ctx.fillStyle = '#4a3426';
          ctx.fillRect(px + CELL_SIZE/2 - 4, py + CELL_SIZE/2 - 4, 8, 12);
          
          // Tree foliage (circle)
          ctx.fillStyle = '#2d4a2d';
          ctx.beginPath();
          ctx.arc(px + CELL_SIZE/2, py + CELL_SIZE/2 - 5, CELL_SIZE/2.5, 0, Math.PI * 2);
          ctx.fill();
          
          // Foliage highlight
          ctx.fillStyle = '#3d5a3d';
          ctx.beginPath();
          ctx.arc(px + CELL_SIZE/2 - 3, py + CELL_SIZE/2 - 8, CELL_SIZE/4, 0, Math.PI * 2);
          ctx.fill();
          
          // Shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(px + CELL_SIZE/2, py + CELL_SIZE - 5, CELL_SIZE/3, CELL_SIZE/6, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
          
        case 3: // Stone floor
          ctx.fillStyle = '#8b7d6b';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          
          // Stone pattern
          ctx.fillStyle = '#9d8f7d';
          ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
          
          // Grout lines
          ctx.strokeStyle = '#7a6d5f';
          ctx.lineWidth = 1;
          ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
          break;
          
        case 4: // Building interior
          ctx.fillStyle = '#3d3329';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          
          // Floor boards
          ctx.strokeStyle = '#4a3f35';
          ctx.lineWidth = 1;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(px, py + (i * CELL_SIZE/3));
            ctx.lineTo(px + CELL_SIZE, py + (i * CELL_SIZE/3));
            ctx.stroke();
          }
          break;
      }
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw base terrain
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y] && grid[y][x] !== undefined) {
            drawTerrain(x, y, grid[y][x]);
          }
        }
      }
      
      // Draw grid lines (subtle)
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= GRID_WIDTH; x++) {
        ctx.beginPath();
        ctx.moveTo(x * CELL_SIZE, 0);
        ctx.lineTo(x * CELL_SIZE, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= GRID_HEIGHT; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * CELL_SIZE);
        ctx.lineTo(canvas.width, y * CELL_SIZE);
        ctx.stroke();
      }
      
      // Draw movement range for active character
      if (dragTarget === 'archer') {
        const movementRange = getMovementRange(archer, ARCHER_MOVEMENT);
        movementRange.forEach(cell => {
          ctx.fillStyle = 'rgba(52, 152, 219, 0.25)';
          ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          
          ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
          ctx.lineWidth = 1;
          ctx.strokeRect(cell.x * CELL_SIZE + 1, cell.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        });
        
        // Draw attack range for archer
        for (let y = 0; y < GRID_HEIGHT; y++) {
          for (let x = 0; x < GRID_WIDTH; x++) {
            if (getDistance(archer, { x, y }) <= ARCHER_RANGE) {
              ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
          }
        }
      } else if (dragTarget === 'knight') {
        const movementRange = getMovementRange(knight, KNIGHT_MOVEMENT);
        movementRange.forEach(cell => {
          ctx.fillStyle = 'rgba(192, 57, 43, 0.25)';
          ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          
          ctx.strokeStyle = 'rgba(192, 57, 43, 0.5)';
          ctx.lineWidth = 1;
          ctx.strokeRect(cell.x * CELL_SIZE + 1, cell.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        });
        
        // Draw attack range for knight (melee)
        for (let y = 0; y < GRID_HEIGHT; y++) {
          for (let x = 0; x < GRID_WIDTH; x++) {
            if (getDistance(knight, { x, y }) <= KNIGHT_RANGE) {
              ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
          }
        }
      }
      
      // Draw line of sight
      if (hasLineOfSight(archer, knight)) {
        const losPoints = getLinePoints(archer, knight);
        losPoints.forEach(point => {
          ctx.fillStyle = 'rgba(241, 196, 15, 0.2)';
          ctx.fillRect(point.x * CELL_SIZE, point.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        });
        
        // Draw sight line
        ctx.strokeStyle = 'rgba(241, 196, 15, 0.6)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(archer.x * CELL_SIZE + CELL_SIZE/2, archer.y * CELL_SIZE + CELL_SIZE/2);
        ctx.lineTo(knight.x * CELL_SIZE + CELL_SIZE/2, knight.y * CELL_SIZE + CELL_SIZE/2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw pathfinding
      const path = findPath(archer, knight);
      if (path.length > 0) {
        ctx.strokeStyle = 'rgba(155, 89, 182, 0.8)';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        ctx.moveTo(path[0].x * CELL_SIZE + CELL_SIZE/2, path[0].y * CELL_SIZE + CELL_SIZE/2);
        for (let i = 1; i < path.length; i++) {
          ctx.lineTo(path[i].x * CELL_SIZE + CELL_SIZE/2, path[i].y * CELL_SIZE + CELL_SIZE/2);
        }
        ctx.stroke();
        
        // Path squares
        path.forEach((point, index) => {
          if (index > 0 && index < path.length - 1) {
            ctx.fillStyle = 'rgba(155, 89, 182, 0.35)';
            ctx.fillRect(point.x * CELL_SIZE, point.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }
        });
      }
      
      // Draw Knight
      const kx = knight.x * CELL_SIZE + CELL_SIZE/2;
      const ky = knight.y * CELL_SIZE + CELL_SIZE/2;
      
      // Knight shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(kx, ky + 15, 12, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Knight body
      ctx.fillStyle = '#c0392b';
      ctx.fillRect(kx - 10, ky - 5, 20, 18);
      
      // Knight armor shine
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(kx - 8, ky - 3, 16, 3);
      
      // Knight helmet
      ctx.fillStyle = '#95a5a6';
      ctx.beginPath();
      ctx.arc(kx, ky - 10, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Helmet shine
      ctx.fillStyle = '#bdc3c7';
      ctx.beginPath();
      ctx.arc(kx - 2, ky - 12, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Sword
      ctx.strokeStyle = '#7f8c8d';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(kx + 12, ky - 5);
      ctx.lineTo(kx + 12, ky + 10);
      ctx.stroke();
      
      // Sword hilt
      ctx.strokeStyle = '#f39c12';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(kx + 8, ky + 5);
      ctx.lineTo(kx + 16, ky + 5);
      ctx.stroke();
      
      // Knight name tag
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(kx - 25, ky - 30, 50, 14);
      ctx.fillStyle = '#e74c3c';
      ctx.font = 'bold 10px Cinzel';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Sir Gareth', kx, ky - 23);
      
      // Draw Archer
      const ax = archer.x * CELL_SIZE + CELL_SIZE/2;
      const ay = archer.y * CELL_SIZE + CELL_SIZE/2;
      
      // Archer shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(ax, ay + 15, 12, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Archer body
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(ax - 8, ay - 5, 16, 18);
      
      // Archer cloak
      ctx.fillStyle = '#2ecc71';
      ctx.beginPath();
      ctx.moveTo(ax - 8, ay - 5);
      ctx.lineTo(ax + 8, ay - 5);
      ctx.lineTo(ax + 10, ay + 15);
      ctx.lineTo(ax - 10, ay + 15);
      ctx.closePath();
      ctx.fill();
      
      // Archer head
      ctx.fillStyle = '#f4c896';
      ctx.beginPath();
      ctx.arc(ax, ay - 10, 7, 0, Math.PI * 2);
      ctx.fill();
      
      // Archer hood
      ctx.fillStyle = '#229954';
      ctx.beginPath();
      ctx.arc(ax, ay - 12, 8, Math.PI, Math.PI * 2);
      ctx.fill();
      
      // Bow
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(ax - 12, ay, 15, -Math.PI/2, Math.PI/2, false);
      ctx.stroke();
      
      // Bowstring
      ctx.strokeStyle = '#d4d4d4';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(ax - 12, ay - 15);
      ctx.lineTo(ax - 12, ay + 15);
      ctx.stroke();
      
      // Quiver
      ctx.fillStyle = '#654321';
      ctx.fillRect(ax + 6, ay - 8, 4, 12);
      
      // Arrows in quiver
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(ax + 8, ay - 8 + i * 4);
        ctx.lineTo(ax + 8, ay - 12 + i * 4);
        ctx.stroke();
      }
      
      // Archer name tag
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(ax - 20, ay - 30, 40, 14);
      ctx.fillStyle = '#3498db';
      ctx.font = 'bold 10px Cinzel';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Elara', ax, ay - 23);
      
      updateUI();
    }
    
    function updateUI() {
      const distance = getDistance(archer, knight);
      const los = hasLineOfSight(archer, knight);
      const archerInRange = distance <= ARCHER_RANGE;
      const knightInRange = distance <= KNIGHT_RANGE;
      const path = findPath(archer, knight);
      
      // Update positions
      document.getElementById('archerPos').textContent = `(${Math.round(archer.x)}, ${Math.round(archer.y)})`;
      document.getElementById('knightPos').textContent = `(${Math.round(knight.x)}, ${Math.round(knight.y)})`;
      
      // Update HP
      document.getElementById('archerHp').textContent = archer.hp;
      document.getElementById('knightHp').textContent = knight.hp;
      
      const archerHpPercent = (archer.hp / archer.maxHp) * 100;
      const knightHpPercent = (knight.hp / knight.maxHp) * 100;
      
      document.querySelector('#archerHpBar .hp-bar-fill').style.width = archerHpPercent + '%';
      document.querySelector('#knightHpBar .hp-bar-fill').style.width = knightHpPercent + '%';
      
      // Update movement remaining (only for current turn)
      if (currentTurn === 'archer') {
        const remainingMovement = Math.max(0, ARCHER_MOVEMENT - movementUsedThisTurn);
        document.getElementById('archerMovement').textContent = remainingMovement * 5;
      } else {
        document.getElementById('archerMovement').textContent = ARCHER_MOVEMENT * 5;
      }
      
      // Update turn indicator
      const turnText = currentTurn === 'archer' ? 'Elara (Archer)' : 'Sir Gareth (Knight - AI)';
      document.getElementById('currentTurn').textContent = turnText;
      
      // Update distance
      document.getElementById('distance').textContent = `${Math.round(distance * 5)} ft`;
      
      // Update line of sight
      const losEl = document.getElementById('los');
      losEl.className = los ? 'status-indicator status-yes' : 'status-indicator status-no';
      losEl.textContent = los ? '‚úì Clear' : '‚úó Blocked';
      
      // Update range status
      const rangeEl = document.getElementById('inRange');
      if (archerInRange || knightInRange) {
        rangeEl.className = 'status-indicator status-yes';
        if (archerInRange && knightInRange) {
          rangeEl.textContent = '‚úì Both in Range';
        } else if (archerInRange) {
          rangeEl.textContent = '‚úì Archer in Range';
        } else {
          rangeEl.textContent = '‚úì Knight in Range';
        }
      } else {
        rangeEl.className = 'status-indicator status-no';
        rangeEl.textContent = '‚úó Out of Range';
      }
      
      document.getElementById('pathLength').textContent = path.length > 0 ? `${(path.length - 1) * 5} ft` : 'Blocked';
      
      // Update attack button visibility (only for player/archer)
      const attackBtn = document.getElementById('attackBtn');
      const attackedIndicator = document.getElementById('attackedIndicator');
      const canAttack = currentTurn === 'archer' && archerInRange && los && !hasAttacked;
      
      if (hasAttacked && currentTurn === 'archer' && !isAnimating) {
        attackBtn.style.display = 'none';
        attackedIndicator.style.display = 'block';
      } else if (canAttack && !isAnimating && !aiThinking) {
        attackBtn.style.display = 'block';
        attackedIndicator.style.display = 'none';
        attackBtn.disabled = false;
      } else {
        attackBtn.style.display = 'none';
        attackedIndicator.style.display = 'none';
      }
      
      // Update end turn button (only available on player's turn)
      const endTurnBtn = document.getElementById('endTurnBtn');
      if (currentTurn === 'archer' && !isAnimating && !aiThinking) {
        endTurnBtn.style.display = 'block';
        endTurnBtn.disabled = false;
      } else if (aiThinking) {
        endTurnBtn.style.display = 'block';
        endTurnBtn.disabled = true;
        endTurnBtn.textContent = 'AI THINKING...';
      } else {
        endTurnBtn.style.display = 'none';
      }
      
      // Reset button text
      if (!aiThinking) {
        endTurnBtn.textContent = 'END TURN ‚Üí';
      }
    }
    
    function getGridPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
      const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
      return { x, y };
    }
    
    canvas.addEventListener('mousedown', (e) => {
      if (isAnimating || aiThinking) return;
      
      const pos = getGridPos(e);
      // Only allow clicking on archer (player character)
      if (Math.abs(pos.x - archer.x) <= 0 && Math.abs(pos.y - archer.y) <= 0) {
        if (currentTurn === 'archer') {
          isDragging = true;
          dragTarget = 'archer';
          canvas.style.cursor = 'grabbing';
        }
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const pos = getGridPos(e);
        const currentChar = dragTarget === 'archer' ? archer : knight;
        const otherChar = dragTarget === 'archer' ? knight : archer;
        const maxMovement = dragTarget === 'archer' ? ARCHER_MOVEMENT : KNIGHT_MOVEMENT;
        
        if (pos.x >= 0 && pos.x < GRID_WIDTH && pos.y >= 0 && pos.y < GRID_HEIGHT && 
            grid[pos.y][pos.x] !== 1 && grid[pos.y][pos.x] !== 2) {
          
          // Check if trying to move to same space as other character
          if (pos.x === Math.round(otherChar.x) && pos.y === Math.round(otherChar.y)) {
            return; // Can't occupy same space
          }
          
          // Calculate total movement from turn start
          const turnStartPos = { x: currentChar.startX, y: currentChar.startY };
          const totalMovementFromStart = getDistance(turnStartPos, pos);
          
          // Check if within remaining movement allowance
          if (totalMovementFromStart <= maxMovement) {
            const oldX = currentChar.x;
            const oldY = currentChar.y;
            
            if (dragTarget === 'archer') {
              archer.x = pos.x;
              archer.y = pos.y;
            }
            
            // Only play sound if actually moved to new cell
            if (Math.floor(oldX) !== Math.floor(pos.x) || Math.floor(oldY) !== Math.floor(pos.y)) {
              playSound('move');
            }
            
            // Update movement used
            movementUsedThisTurn = totalMovementFromStart;
            
            updateUI();
            draw();
          }
        }
      } else {
        const pos = getGridPos(e);
        // Only show grab cursor for archer on player's turn
        const hoveringArcher = Math.abs(pos.x - archer.x) <= 0 && Math.abs(pos.y - archer.y) <= 0;
        
        if (hoveringArcher && currentTurn === 'archer' && !aiThinking) {
          canvas.style.cursor = 'grab';
        } else {
          canvas.style.cursor = 'crosshair';
        }
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      dragTarget = null;
      canvas.style.cursor = 'crosshair';
      updateUI(); // Update UI to show current movement remaining
      draw();
    });
    
    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      dragTarget = null;
      canvas.style.cursor = 'crosshair';
      draw();
    });
    
    // Attack button event listener
    document.getElementById('attackBtn').addEventListener('click', () => {
      if (currentTurn === 'archer') {
        performAttack(archer, knight);
      } else {
        performAttack(knight, archer);
      }
    });
    
    // End turn button event listener
    document.getElementById('endTurnBtn').addEventListener('click', () => {
      if (!isAnimating) {
        endTurn();
      }
    });
    
    // Reset button event listener
    document.getElementById('resetBtn').addEventListener('click', () => {
      resetGame();
    });
    
    // Play again button event listener
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      hideGameOver();
      resetGame();
    });
    
    // Start game button event listener
    document.getElementById('startGameBtn').addEventListener('click', () => {
      hideSplashScreen();
      // Small delay before showing turn indicator
      setTimeout(() => {
        showTurnIndicator(currentTurn);
        // If knight goes first, trigger AI
        if (currentTurn === 'knight') {
          setTimeout(() => {
            knightAI();
          }, 2500);
        }
      }, 600);
    });
    
    // Reset game function
    function resetGame() {
      // Stop any ongoing animations
      isAnimating = false;
      aiThinking = false;
      isDragging = false;
      dragTarget = null;
      movementUsedThisTurn = 0;
      hasAttacked = false;
      
      // Regenerate courtyard layout
      generateCourtyard();
      
      // Find random starting positions
      const positions = findRandomStartingPositions();
      
      // Reset character positions and stats
      archer.x = positions.archerPos.x;
      archer.y = positions.archerPos.y;
      archer.startX = positions.archerPos.x;
      archer.startY = positions.archerPos.y;
      archer.hp = archer.maxHp;
      delete archer.startPos;
      
      knight.x = positions.knightPos.x;
      knight.y = positions.knightPos.y;
      knight.startX = positions.knightPos.x;
      knight.startY = positions.knightPos.y;
      knight.hp = knight.maxHp;
      delete knight.startPos;
      
      // Randomize starting turn
      currentTurn = randomizeStartingTurn();
      
      // Update UI and redraw
      updateUI();
      draw();
      
      // Show who goes first
      setTimeout(() => {
        showTurnIndicator(currentTurn);
      }, 300);
      
      // If knight goes first, trigger AI after indicator
      if (currentTurn === 'knight') {
        setTimeout(() => {
          knightAI();
        }, 2500);
      }
    }
    
    // Initialize game with random positions
    function initializeGame() {
      const positions = findRandomStartingPositions();
      archer.x = positions.archerPos.x;
      archer.y = positions.archerPos.y;
      archer.startX = positions.archerPos.x;
      archer.startY = positions.archerPos.y;
      knight.x = positions.knightPos.x;
      knight.y = positions.knightPos.y;
      knight.startX = positions.knightPos.x;
      knight.startY = positions.knightPos.y;
      
      currentTurn = randomizeStartingTurn();
      
      draw();
      
      // Show splash screen on initial load
      // Game will start when user clicks "Begin Battle"
    }
    
    initializeGame();
  </script>
</body>
</html>
